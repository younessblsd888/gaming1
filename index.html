<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>üèÉ Subway Surfers ‚Äî Farcaster Mini App</title>
<style>
  :root { color-scheme: dark; }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: linear-gradient(135deg, #0a0e13 0%, #1a1f2e 100%);
    color: #e7ecf0;
    font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
    overflow: hidden;
  }
  .overlay { position: fixed; inset: 0; display: grid; place-items: center; background: rgba(8,11,14,.85); backdrop-filter: blur(4px); padding: 16px; z-index: 100; }
  .card { background: #12171b; border: 1px solid #1f2a32; border-radius: 14px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,.35); max-width: 500px; }
  .hidden { display: none !important; }
  h1 { font-size: 28px; font-weight: 900; margin-bottom: 12px; text-shadow: 0 2px 10px rgba(56,189,248,0.5); }
  .muted { color: #9aa7b1; font-size: 14px; line-height: 1.4; margin-bottom: 16px; }
  .btn-primary {
    padding: 14px 28px; background: linear-gradient(135deg, #ff8c42, #ff6b1a); color: #fff;
    border: none; border-radius: 12px; font-weight: 900; font-size: 16px; cursor: pointer;
    box-shadow: 0 6px 20px rgba(255,107,26,0.4); transition: all 0.2s; text-transform: uppercase;
  }
  .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(255,107,26,0.5); }
  .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; }
  #status { margin-top: 15px; font-size: 13px; line-height: 1.5; background: #0f151a; border: 1px solid #1f2a32; border-radius: 10px; padding: 12px; }
  #status b { color: #cde7d8; }
  #status .ok { color: #4ade80; }
  #status .warn { color: #fbbf24; }
  #status .err { color: #f87171; }
  #status a { color: #86c6ff; text-decoration: none; }
  #play-again {
    position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
    padding: 16px 32px; background: linear-gradient(135deg, #ff8c42, #ff6b1a); color: #fff;
    border: none; border-radius: 12px; font-weight: 900; font-size: 18px; cursor: pointer;
    box-shadow: 0 10px 40px rgba(255,107,26,0.5); z-index: 50;
  }
  #root { width: 100vw; height: 100vh; }
</style>
</head>
<body>
  <div id="intro-overlay" class="overlay hidden">
    <div class="card" role="dialog" aria-modal="true">
      <h1>üèÉ Play Subway Surfers</h1>
      <p class="muted">A small Base transfer is required to start playing (mobile & desktop supported).</p>
      <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap;">
        <div class="muted" style="font-size: 12px;">Change recipient/amount in code if needed.</div>
        <button id="play" class="btn-primary">üí∞ Pay & Play</button>
      </div>
      <div id="status" class="hidden"></div>
    </div>
  </div>

  <div id="root"></div>
  <button id="play-again" class="hidden">üí∞ Pay & Play Again</button>

<script type="module">
import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
sdk.actions.ready();

const USE_BASE_SEPOLIA = false;
const RECIPIENT = "0x1896A467359684afDdFe091d83B9441eeAaBcb80";
const AMOUNT_ETH = "0.00001";
const BASE_MAINNET = { chainId: "0x2105", explorer: "https://basescan.org/tx/" };
const BASE_SEPOLIA = { chainId: "0x14a34", explorer: "https://sepolia.basescan.org/tx/" };
const TARGET = USE_BASE_SEPOLIA ? BASE_SEPOLIA : BASE_MAINNET;

const statusEl = document.getElementById('status');
const playBtn = document.getElementById('play');
const playAgainBtn = document.getElementById('play-again');

const showStatus = () => statusEl.classList.remove('hidden');
const addLine = html => { showStatus(); statusEl.insertAdjacentHTML('beforeend', `<div>${html}</div>`); };
const clearStatus = () => statusEl.innerHTML = '';
const disable = (el, yes=true) => { if (el) el.disabled = yes; };

function parseEther(x) {
  const [w, f=""] = String(x).split('.');
  const frac = (f + '0'.repeat(18)).slice(0, 18);
  return '0x' + (BigInt(w) * 10n**18n + BigInt(frac)).toString(16);
}

async function getProvider() {
  try {
    const p = await sdk.wallet.getEthereumProvider();
    if (p) return p;
  } catch {}
  return window.ethereum ?? null;
}

async function ensureChain(provider, chainId) {
  const current = (await provider.request({ method: 'eth_chainId' }))?.toLowerCase();
  if (current === chainId.toLowerCase()) return;
  try {
    await provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId }] });
  } catch (e) {
    if (e?.code === 4902) {
      await provider.request({ method: 'wallet_addEthereumChain', params: [{ chainId }] });
      await provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId }] });
    } else { throw e; }
  }
}

async function requiredPayment() {
  clearStatus();
  addLine(`<b>Step 1:</b> Locating wallet provider‚Ä¶`);
  const provider = await getProvider();
  if (!provider) {
    addLine(`<span class="err">No wallet available.</span> Open in Farcaster or enable a wallet.`);
    throw new Error('NO_PROVIDER');
  }
  addLine(`<span class="ok">Provider ready.</span>`);

  addLine(`<b>Step 2:</b> Requesting accounts‚Ä¶`);
  const [from] = await provider.request({ method: 'eth_requestAccounts' });
  addLine(`<span class="ok">Account: ${from.slice(0,6)}‚Ä¶${from.slice(-4)}</span>`);

  addLine(`<b>Step 3:</b> Switching to Base${USE_BASE_SEPOLIA?' Sepolia':''}‚Ä¶`);
  await ensureChain(provider, TARGET.chainId);
  addLine(`<span class="ok">On Base${USE_BASE_SEPOLIA?' Sepolia':''}.</span>`);

  addLine(`<b>Step 4:</b> Sending ${AMOUNT_ETH} ETH to ${RECIPIENT.slice(0,6)}‚Ä¶${RECIPIENT.slice(-4)}‚Ä¶`);
  const hash = await provider.request({
    method: 'eth_sendTransaction',
    params: [{ from, to: RECIPIENT, value: parseEther(AMOUNT_ETH) }]
  });
  addLine(`<span class="ok">TX sent.</span> <a target="_blank" rel="noopener" href="${TARGET.explorer}${hash}">View on Basescan</a>`);
  return hash;
}

async function payThen(action, triggerBtn) {
  try {
    disable(triggerBtn, true);
    await requiredPayment();
    await action();
  } catch (e) {
    console.warn('Payment gate blocked action:', e);
    addLine(`<span class="warn">Payment required. Please try again.</span>`);
  } finally {
    disable(triggerBtn, false);
  }
}

window.payThen = payThen;

playBtn.addEventListener('click', (e) => {
  e.preventDefault();
  payThen(() => {
    document.getElementById('intro-overlay').classList.add('hidden');
    window.initGame();
  }, playBtn);
});

window.addEventListener('error', e => console.error('Error:', e.error || e));
window.addEventListener('unhandledrejection', e => console.error('Unhandled promise:', e.reason));
</script>

<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;
const LANES = [-1, 0, 1];
const GAME_SPEED = 5;
const JUMP_POWER = 15;
const GRAVITY = 0.8;

const SubwaySurfers = () => {
  const [gameState, setGameState] = useState('playing');
  const [score, setScore] = useState(0);
  const [coins, setCoins] = useState(0);
  const [highScore, setHighScore] = useState(0);
  const [distance, setDistance] = useState(0);
  const [lives, setLives] = useState(3);
  const [playerLane, setPlayerLane] = useState(0);
  const [playerY, setPlayerY] = useState(0);
  const [isJumping, setIsJumping] = useState(false);
  const [obstacles, setObstacles] = useState([]);
  const [collectibles, setCollectibles] = useState([]);
  const [powerUps, setPowerUps] = useState([]);
  const [activePowerUp, setActivePowerUp] = useState(null);
  const [powerUpTimer, setPowerUpTimer] = useState(0);
  const [isInvincible, setIsInvincible] = useState(false);
  
  const speedRef = useRef(GAME_SPEED);
  const obstacleSpawnRef = useRef(0);
  const coinSpawnRef = useRef(0);
  const powerUpSpawnRef = useRef(0);
  const playerVelocityYRef = useRef(0);

  useEffect(() => {
    const loadHighScore = async () => {
      try {
        if (window.storage) {
          const result = await window.storage.get('subway-highscore');
          if (result) setHighScore(parseInt(result.value));
        }
      } catch (error) {
        console.log('No high score found');
      }
    };
    loadHighScore();
  }, []);

  const saveHighScore = async (newScore) => {
    try {
      if (window.storage) {
        await window.storage.set('subway-highscore', newScore.toString());
      }
    } catch (error) {
      console.error('Failed to save high score:', error);
    }
  };

  const endGame = useCallback(() => {
    setGameState('gameOver');
    const playAgainBtn = document.getElementById('play-again');
    if (playAgainBtn) playAgainBtn.classList.remove('hidden');
  }, []);

  const loseLife = useCallback(() => {
    setIsInvincible(prev => {
      if (prev) return prev;
      
      setLives(currentLives => {
        const newLives = currentLives - 1;
        if (newLives <= 0) {
          setTimeout(() => endGame(), 100);
          return 0;
        }
        return newLives;
      });
      
      setTimeout(() => setIsInvincible(false), 2000);
      return true;
    });
  }, [endGame]);

  const moveLane = useCallback((direction) => {
    setGameState(state => {
      if (state !== 'playing') return state;
      setPlayerLane(prev => Math.max(-1, Math.min(1, prev + direction)));
      return state;
    });
  }, []);

  const jump = useCallback(() => {
    setGameState(state => {
      if (state !== 'playing') return state;
      setIsJumping(jumping => {
        if (jumping) return jumping;
        playerVelocityYRef.current = JUMP_POWER;
        return true;
      });
      return state;
    });
  }, []);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === 'ArrowLeft') moveLane(-1);
      if (e.key === 'ArrowRight') moveLane(1);
      if (e.key === 'ArrowUp' || e.key === ' ') {
        e.preventDefault();
        jump();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [moveLane, jump]);

  const handleGameClick = () => {
    if (gameState === 'playing') jump();
  };

  useEffect(() => {
    if (gameState === 'gameOver' && score > highScore) {
      setHighScore(score);
      saveHighScore(score);
    }
  }, [gameState, score, highScore]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const gameLoop = setInterval(() => {
      setDistance(prev => {
        const newDist = prev + 1;
        speedRef.current = GAME_SPEED + Math.floor(newDist / 500) * 0.5;
        return newDist;
      });
      
      setScore(prev => prev + 1);

      setPlayerY(prev => {
        const velocity = playerVelocityYRef.current;
        const newY = prev + velocity;
        playerVelocityYRef.current = velocity - GRAVITY;
        
        if (newY <= 0) {
          playerVelocityYRef.current = 0;
          setIsJumping(false);
          return 0;
        }
        return newY;
      });

      obstacleSpawnRef.current++;
      if (obstacleSpawnRef.current > 100 - speedRef.current * 5) {
        obstacleSpawnRef.current = 0;
        const type = Math.random() > 0.5 ? 'barrier' : 'train';
        const lane = LANES[Math.floor(Math.random() * LANES.length)];
        setObstacles(prev => [...prev, { id: Date.now(), type, lane, y: 600, height: type === 'train' ? 80 : 50 }]);
      }

      coinSpawnRef.current++;
      if (coinSpawnRef.current > 40) {
        coinSpawnRef.current = 0;
        const lane = LANES[Math.floor(Math.random() * LANES.length)];
        const pattern = Math.random();
        if (pattern > 0.7) {
          const baseId = Date.now();
          const newCoins = [];
          for (let i = 0; i < 5; i++) {
            newCoins.push({ id: baseId + i, type: 'coin', lane, y: 600 + i * 40, value: 1 });
          }
          setCollectibles(prev => [...prev, ...newCoins]);
        } else {
          setCollectibles(prev => [...prev, { id: Date.now(), type: 'coin', lane, y: 600, value: 1 }]);
        }
      }

      powerUpSpawnRef.current++;
      if (powerUpSpawnRef.current > 300) {
        powerUpSpawnRef.current = 0;
        const types = ['jetpack', 'magnet', 'multiplier'];
        const type = types[Math.floor(Math.random() * types.length)];
        const lane = LANES[Math.floor(Math.random() * LANES.length)];
        setPowerUps(prev => [...prev, { id: Date.now(), type, lane, y: 600 }]);
      }

      setObstacles(prev => prev.map(obs => ({ ...obs, y: obs.y - speedRef.current })).filter(obs => obs.y > -100));
      setCollectibles(prev => prev.map(col => ({ ...col, y: col.y - speedRef.current })).filter(col => col.y > -50));
      setPowerUps(prev => prev.map(pu => ({ ...pu, y: pu.y - speedRef.current })).filter(pu => pu.y > -50));

      setPowerUpTimer(prev => {
        if (prev <= 0) {
          setActivePowerUp(null);
          return 0;
        }
        return prev - 16;
      });
    }, 16);

    return () => clearInterval(gameLoop);
  }, [gameState]);

  useEffect(() => {
    if (gameState !== 'playing') return;

    const collisionCheck = setInterval(() => {
      const playerHeight = 60;
      const playerBottom = 400 - playerY;
      const playerTop = playerBottom - playerHeight;

      obstacles.forEach(obs => {
        if (obs.lane === playerLane && obs.y < 450 && obs.y > 350) {
          if (obs.type === 'train' && playerTop < 400 - obs.height) {
            if (activePowerUp !== 'jetpack' && !isInvincible) {
              loseLife();
              setObstacles(prev => prev.filter(o => o.id !== obs.id));
            }
          } else if (obs.type === 'barrier' && playerY < 30) {
            if (activePowerUp !== 'jetpack' && !isInvincible) {
              loseLife();
              setObstacles(prev => prev.filter(o => o.id !== obs.id));
            }
          }
        }
      });

      collectibles.forEach(col => {
        if (col.lane === playerLane && col.y < 450 && col.y > 350) {
          setCoins(prev => prev + col.value);
          const multiplier = activePowerUp === 'multiplier' ? 2 : 1;
          setScore(prev => prev + 10 * multiplier);
          setCollectibles(prev => prev.filter(c => c.id !== col.id));
        }
      });

      powerUps.forEach(pu => {
        if (pu.lane === playerLane && pu.y < 450 && pu.y > 350) {
          setActivePowerUp(pu.type);
          setPowerUpTimer(5000);
          setPowerUps(prev => prev.filter(p => p.id !== pu.id));
        }
      });

      if (activePowerUp === 'magnet') {
        collectibles.forEach(col => {
          if (Math.abs(col.lane - playerLane) <= 1 && col.y < 500 && col.y > 300) {
            setCoins(prev => prev + col.value);
            setScore(prev => prev + 10);
            setCollectibles(prev => prev.filter(c => c.id !== col.id));
          }
        });
      }
    }, 16);

    return () => clearInterval(collisionCheck);
  }, [gameState, playerY, playerLane, obstacles, collectibles, powerUps, activePowerUp, isInvincible, loseLife]);

  const getLaneX = (lane) => lane * 80 + window.innerWidth / 2 - 40;

  const PixelPlayer = ({ isInvincible, activePowerUp }) => {
    const opacity = isInvincible ? 0.5 : 1;
    const glowColor = activePowerUp === 'jetpack' ? '#facc15' : activePowerUp === 'magnet' ? '#a855f7' : activePowerUp === 'multiplier' ? '#22c55e' : 'none';
    
    return (
      <svg width="40" height="55" viewBox="0 0 16 21" style={{ opacity, filter: glowColor !== 'none' ? `drop-shadow(0 0 4px ${glowColor})` : 'none' }}>
        <rect x="5" y="0" width="6" height="5" fill="#FFB6A3"/>
        <rect x="4" y="0" width="8" height="2" fill="#4A3829"/>
        <rect x="6" y="2" width="1" height="1" fill="#000"/>
        <rect x="9" y="2" width="1" height="1" fill="#000"/>
        <rect x="7" y="4" width="2" height="1" fill="#000"/>
        <rect x="4" y="5" width="8" height="7" fill="#3B82F6"/>
        <rect x="2" y="6" width="2" height="5" fill="#FFB6A3"/>
        <rect x="12" y="6" width="2" height="5" fill="#FFB6A3"/>
        <rect x="5" y="12" width="2" height="5" fill="#1E3A8A"/>
        <rect x="9" y="12" width="2" height="5" fill="#1E3A8A"/>
        <rect x="4" y="17" width="3" height="2" fill="#000"/>
        <rect x="9" y="17" width="3" height="2" fill="#000"/>
      </svg>
    );
  };

  return (
    <div className="w-full h-screen bg-gradient-to-b from-blue-900 to-blue-700 flex flex-col items-center justify-center overflow-hidden select-none" style={{ imageRendering: 'pixelated' }}>
      {gameState === 'playing' && (
        <>
          <div className="absolute top-2 left-2 right-2 z-20 flex justify-between items-start flex-wrap gap-2 text-xs">
            <div className="bg-black border-2 border-white text-yellow-400 px-2 py-1" style={{ fontFamily: 'monospace' }}>
              <p className="text-xs">SCORE: {score}</p>
            </div>
            <div className="bg-black border-2 border-white text-white px-2 py-1" style={{ fontFamily: 'monospace' }}>
              <div className="flex gap-1">
                LIVES: {[...Array(3)].map((_, i) => (
                  <span key={i}>{i < lives ? '‚ù§Ô∏è' : 'üñ§'}</span>
                ))}
              </div>
            </div>
            <div className="bg-black border-2 border-white text-yellow-400 px-2 py-1" style={{ fontFamily: 'monospace' }}>
              <p className="text-xs">COINS: {coins}</p>
            </div>
          </div>

          {activePowerUp && (
            <div className="absolute top-16 left-1/2 transform -translate-x-1/2 z-20 bg-purple-600 border-2 border-white text-white px-3 py-1 font-bold text-xs" style={{ fontFamily: 'monospace' }}>
              {activePowerUp.toUpperCase()} {Math.ceil(powerUpTimer / 1000)}s
            </div>
          )}

          {isInvincible && (
            <div className="absolute top-24 left-1/2 transform -translate-x-1/2 z-20 bg-blue-600 border-2 border-white text-white px-3 py-1 font-bold animate-pulse text-xs" style={{ fontFamily: 'monospace' }}>
              INVINCIBLE!
            </div>
          )}

          <div className="relative w-full h-full cursor-pointer" onClick={handleGameClick}>
            <div className="absolute bottom-0 w-full h-full">
              {LANES.map(lane => (
                <div key={lane} className="absolute h-full bg-gray-700 border-l-2 border-r-2 border-white border-opacity-30" style={{ left: `${getLaneX(lane) - 30}px`, width: '60px' }}>
                  {[10, 30, 50, 70].map((top, i) => (
                    <div key={i} className="absolute w-full border-b-2 border-dashed border-white border-opacity-40" style={{ top: `${top}%` }}></div>
                  ))}
                </div>
              ))}
            </div>

            {obstacles.map(obs => (
              <div key={obs.id} className="absolute border-2 border-white" style={{ left: `${getLaneX(obs.lane) - 20}px`, bottom: `${obs.y}px`, width: '40px', height: `${obs.height}px`, backgroundColor: obs.type === 'train' ? '#dc2626' : '#eab308', boxShadow: '2px 2px 0px rgba(0,0,0,0.5)' }}>
                <div className="text-white text-center font-bold text-xl">{obs.type === 'train' ? '‚ñà' : '‚ñ≤'}</div>
              </div>
            ))}

            {collectibles.map(col => (
              <div key={col.id} className="absolute border-2 border-yellow-600 bg-yellow-400 rounded-full" style={{ left: `${getLaneX(col.lane) - 10}px`, bottom: `${col.y}px`, width: '20px', height: '20px', boxShadow: '1px 1px 0px rgba(0,0,0,0.5)' }}></div>
            ))}

            {powerUps.map(pu => (
              <div key={pu.id} className="absolute border-2 border-white flex items-center justify-center text-white font-bold" style={{ left: `${getLaneX(pu.lane) - 12}px`, bottom: `${pu.y}px`, width: '24px', height: '24px', backgroundColor: pu.type === 'jetpack' ? '#facc15' : pu.type === 'magnet' ? '#a855f7' : '#22c55e', boxShadow: '2px 2px 0px rgba(0,0,0,0.5)', fontSize: '14px' }}>
                {pu.type === 'jetpack' && '‚Üë'}
                {pu.type === 'magnet' && 'M'}
                {pu.type === 'multiplier' && '√ó2'}
              </div>
            ))}

            <div className="absolute" style={{ left: `${getLaneX(playerLane) - 20}px`, bottom: `${400 + playerY}px` }}>
              <PixelPlayer isInvincible={isInvincible} activePowerUp={activePowerUp} />
            </div>
          </div>

          <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-20 flex gap-4">
            <button onClick={(e) => { e.stopPropagation(); moveLane(-1); }} className="bg-white border-2 border-black p-3 active:scale-95" style={{ boxShadow: '2px 2px 0px #000' }}>
              <svg width="24" height="24" viewBox="0 0 24 24" fill="black">
                <path d="M15 18l-6-6 6-6v12z"/>
              </svg>
            </button>
            <button onClick={(e) => { e.stopPropagation(); moveLane(1); }} className="bg-white border-2 border-black p-3 active:scale-95" style={{ boxShadow: '2px 2px 0px #000' }}>
              <svg width="24" height="24" viewBox="0 0 24 24" fill="black">
                <path d="M9 6l6 6-6 6V6z"/>
              </svg>
            </button>
          </div>
        </>
      )}

      {gameState === 'gameOver' && (
        <div className="text-center z-10 p-4">
          <h2 className="text-4xl font-bold text-red-600 mb-4" style={{ fontFamily: 'monospace', textShadow: '3px 3px 0px #000' }}>GAME OVER!</h2>
          <div className="bg-black border-4 border-white p-6 mb-4">
            <p className="text-2xl font-bold text-yellow-400 mb-2" style={{ fontFamily: 'monospace' }}>SCORE: {score}</p>
            <p className="text-xl font-bold text-white mb-2" style={{ fontFamily: 'monospace' }}>COINS: {coins}</p>
            <p className="text-lg text-gray-400" style={{ fontFamily: 'monospace' }}>HIGH: {highScore}</p>
          </div>
        </div>
      )}
    </div>
  );
};

window.initGame = () => {
  ReactDOM.render(<SubwaySurfers />, document.getElementById('root'));
};

if (document.getElementById('intro-overlay').classList.contains('hidden')) {
  window.initGame();
}

document.getElementById('play-again').addEventListener('click', async (e) => {
  e.preventDefault();
  const btn = e.target;
  const payThen = window.payThen || async (action) => action();
  await payThen(async () => {
    btn.classList.add('hidden');
    window.initGame();
  }, btn);
});
</script>
</body>
</html>
