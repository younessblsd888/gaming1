<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Tic-Tac-Toe 🎮 — Farcaster Mini App</title>
<style>
  :root { color-scheme: dark; }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: linear-gradient(135deg, #0a0e13 0%, #1a1f2e 100%);
    color: #e7ecf0;
    font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100dvh;
    padding: 20px;
  }
  .wrap { width: min(500px, 96vw); position: relative; }
  .card { background: #12171b; border: 1px solid #1f2a32; border-radius: 14px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
  .overlay { position: fixed; inset: 0; display: grid; place-items: center; background: rgba(8,11,14,.85); backdrop-filter: blur(4px); padding: 16px; z-index: 100; }
  .hidden { display: none !important; }
  
  h1 {
    font-size: 28px;
    font-weight: 900;
    margin-bottom: 12px;
    text-shadow: 0 2px 10px rgba(56,189,248,0.5);
  }
  
  .muted {
    color: #9aa7b1;
    font-size: 14px;
    line-height: 1.4;
    margin-bottom: 16px;
  }
  
  .btn-primary {
    padding: 14px 28px;
    background: linear-gradient(135deg, #ff8c42, #ff6b1a);
    color: #fff;
    border: none;
    border-radius: 12px;
    font-weight: 900;
    font-size: 16px;
    cursor: pointer;
    box-shadow: 0 6px 20px rgba(255,107,26,0.4);
    transition: all 0.2s;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .btn-primary:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(255,107,26,0.5);
  }
  
  .btn-primary:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  
  .btn-secondary {
    padding: 12px 24px;
    background: linear-gradient(135deg, #38bdf8, #34d399);
    color: #0a1929;
    border: none;
    border-radius: 10px;
    font-weight: 900;
    font-size: 14px;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(56,189,248,0.3);
    transition: all 0.2s;
    letter-spacing: 0.5px;
    text-transform: uppercase;
  }
  
  .btn-secondary:hover:not(:disabled) {
    transform: translateY(-2px);
  }
  
  .btn-secondary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  #status {
    margin-top: 15px;
    font-size: 13px;
    line-height: 1.5;
    background: #0f151a;
    border: 1px solid #1f2a32;
    border-radius: 10px;
    padding: 12px;
  }
  
  #status b { color: #cde7d8; }
  #status .ok { color: #4ade80; }
  #status .warn { color: #fbbf24; }
  #status .err { color: #f87171; }
  #status a { color: #86c6ff; text-decoration: none; }
  
  #game-container {
    margin-top: 20px;
  }
  
  .stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 20px;
  }
  
  .stat-card {
    background: #0f151a;
    border: 2px solid #1f2a32;
    border-radius: 10px;
    padding: 12px;
    text-align: center;
  }
  
  .stat-label {
    font-size: 11px;
    color: #9aa7b1;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
  }
  
  .stat-value {
    font-size: 24px;
    font-weight: 900;
    color: #fff;
  }
  
  .difficulty-badge {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 11px;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .diff-easy { background: #22c55e; color: #000; }
  .diff-medium { background: #fbbf24; color: #000; }
  .diff-hard { background: #ef4444; color: #fff; }
  
  .board {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin: 20px 0;
    max-width: 400px;
    margin-left: auto;
    margin-right: auto;
  }
  
  .cell {
    aspect-ratio: 1;
    background: #1a2332;
    border: 3px solid #2a3f5f;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 48px;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
  }
  
  .cell:hover:not(.filled) {
    background: #243447;
    border-color: #3a5f8f;
    transform: scale(1.05);
  }
  
  .cell.filled {
    cursor: not-allowed;
  }
  
  .cell.player {
    color: #38bdf8;
    text-shadow: 0 0 20px rgba(56,189,248,0.6);
  }
  
  .cell.ai {
    color: #f87171;
    text-shadow: 0 0 20px rgba(248,113,113,0.6);
  }
  
  .cell.winner {
    background: #22c55e;
    animation: pulse 0.5s ease-in-out infinite;
  }
  
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  
  .game-info {
    text-align: center;
    margin: 20px 0;
  }
  
  .game-status {
    font-size: 20px;
    font-weight: 900;
    margin-bottom: 10px;
    min-height: 30px;
  }
  
  .controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-top: 20px;
  }
  
  .level-up-notice {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    color: #000;
    padding: 12px 20px;
    border-radius: 10px;
    font-weight: 900;
    text-align: center;
    margin: 15px 0;
    animation: slideIn 0.5s ease-out;
  }
  
  @keyframes slideIn {
    from {
      transform: translateY(-20px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
  
  #play-again {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    padding: 16px 32px;
    background: linear-gradient(135deg, #ff8c42, #ff6b1a);
    color: #fff;
    border: none;
    border-radius: 12px;
    font-weight: 900;
    font-size: 18px;
    cursor: pointer;
    box-shadow: 0 10px 40px rgba(255,107,26,0.5);
    z-index: 50;
  }
</style>
</head>
<body>
  <div class="wrap">
    <!-- Intro Overlay -->
    <div id="intro-overlay" class="overlay">
      <div class="card" role="dialog" aria-modal="true">
        <h1>🎮 Play Tic-Tac-Toe AI</h1>
        <p class="muted">Challenge the AI! Start on Easy, beat it to unlock Medium, then Hard mode. A small Base transfer is required to start playing.</p>
        <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap;">
          <div class="muted" style="font-size: 12px;">Change recipient/amount in code if needed.</div>
          <button id="play" class="btn-primary">💰 Pay & Play</button>
        </div>
        <div id="status" class="hidden"></div>
      </div>
    </div>

    <div id="game-container" class="hidden">
      <div class="card">
        <h1 style="text-align: center; margin-bottom: 20px;">🎮 Tic-Tac-Toe AI</h1>
        
        <div class="stats">
          <div class="stat-card">
            <div class="stat-label">Wins</div>
            <div class="stat-value" id="wins">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Losses</div>
            <div class="stat-value" id="losses">0</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Lives</div>
            <div class="stat-value" id="attempts" style="color: #ef4444;">1</div>
          </div>
        </div>
        
        <div style="text-align: center; margin-bottom: 15px;">
          <span class="stat-label">Difficulty: </span>
          <span class="difficulty-badge" id="difficulty-badge">Easy</span>
        </div>
        
        <div id="level-up-notice" class="level-up-notice hidden"></div>
        
        <div class="game-info">
          <div class="game-status" id="game-status">Your turn! (X)</div>
        </div>
        
        <div class="board" id="board">
          <div class="cell" data-index="0"></div>
          <div class="cell" data-index="1"></div>
          <div class="cell" data-index="2"></div>
          <div class="cell" data-index="3"></div>
          <div class="cell" data-index="4"></div>
          <div class="cell" data-index="5"></div>
          <div class="cell" data-index="6"></div>
          <div class="cell" data-index="7"></div>
          <div class="cell" data-index="8"></div>
        </div>
        
        <div class="controls">
          <button id="reset-btn" class="btn-secondary">🔄 New Game</button>
        </div>
      </div>
    </div>

    <button id="play-again" class="hidden">💰 Pay & Play Again</button>
  </div>

<script type="module">
import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
sdk.actions.ready();

/* ===== CONFIG ===== */
const USE_BASE_SEPOLIA = false;
const RECIPIENT = "0x1896A467359684afDdFe091d83B9441eeAaBcb80";
const AMOUNT_ETH = "0.00001";

const BASE_MAINNET = { chainId: "0x2105",  explorer: "https://basescan.org/tx/" };
const BASE_SEPOLIA = { chainId: "0x14a34", explorer: "https://sepolia.basescan.org/tx/" };
const TARGET = USE_BASE_SEPOLIA ? BASE_SEPOLIA : BASE_MAINNET;

/* ===== DOM ===== */
const statusEl = document.getElementById('status');
const playBtn = document.getElementById('play');
const playAgainBtn = document.getElementById('play-again');
const gameContainer = document.getElementById('game-container');
const board = document.getElementById('board');
const gameStatus = document.getElementById('game-status');
const resetBtn = document.getElementById('reset-btn');
const winsEl = document.getElementById('wins');
const lossesEl = document.getElementById('losses');
const attemptsEl = document.getElementById('attempts');
const difficultyBadge = document.getElementById('difficulty-badge');
const levelUpNotice = document.getElementById('level-up-notice');

const showStatus = () => statusEl.classList.remove('hidden');
const addLine = html => { showStatus(); statusEl.insertAdjacentHTML('beforeend', `<div>${html}</div>`); };
const clearStatus = () => statusEl.innerHTML = '';
const disable = (el, yes=true) => { if (el) el.disabled = yes; };

/* ===== Wallet Helpers ===== */
function parseEther(x) {
  const [w, f=""] = String(x).split('.');
  const frac = (f + '0'.repeat(18)).slice(0, 18);
  return '0x' + (BigInt(w) * 10n**18n + BigInt(frac)).toString(16);
}

async function getProvider() {
  try {
    const p = await sdk.wallet.getEthereumProvider();
    if (p) return p;
  } catch {}
  return window.ethereum ?? null;
}

async function ensureChain(provider, chainId) {
  const current = (await provider.request({ method: 'eth_chainId' }))?.toLowerCase();
  if (current === chainId.toLowerCase()) return;
  try {
    await provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId }] });
  } catch (e) {
    if (e?.code === 4902) {
      await provider.request({ method: 'wallet_addEthereumChain', params: [{ chainId }] });
      await provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId }] });
    } else { throw e; }
  }
}

async function requiredPayment() {
  clearStatus();
  addLine(`<b>Step 1:</b> Locating wallet provider…`);
  const provider = await getProvider();
  if (!provider) {
    addLine(`<span class="err">No wallet available.</span> Open in Farcaster or enable a wallet.`);
    throw new Error('NO_PROVIDER');
  }
  addLine(`<span class="ok">Provider ready.</span>`);

  addLine(`<b>Step 2:</b> Requesting accounts…`);
  const [from] = await provider.request({ method: 'eth_requestAccounts' });
  addLine(`<span class="ok">Account: ${from.slice(0,6)}…${from.slice(-4)}</span>`);

  addLine(`<b>Step 3:</b> Switching to Base${USE_BASE_SEPOLIA?' Sepolia':''}…`);
  await ensureChain(provider, TARGET.chainId);
  addLine(`<span class="ok">On Base${USE_BASE_SEPOLIA?' Sepolia':''}.</span>`);

  addLine(`<b>Step 4:</b> Sending ${AMOUNT_ETH} ETH to ${RECIPIENT.slice(0,6)}…${RECIPIENT.slice(-4)}…`);
  const hash = await provider.request({
    method: 'eth_sendTransaction',
    params: [{ from, to: RECIPIENT, value: parseEther(AMOUNT_ETH) }]
  });
  addLine(`<span class="ok">TX sent.</span> <a target="_blank" rel="noopener" href="${TARGET.explorer}${hash}">View on Basescan</a>`);
  return hash;
}

async function payThen(action, triggerBtn) {
  try {
    disable(triggerBtn, true);
    await requiredPayment();
    await action();
  } catch (e) {
    console.warn('Payment gate blocked action:', e);
    addLine(`<span class="warn">Payment required. Please try again.</span>`);
  } finally {
    disable(triggerBtn, false);
  }
}

/* ===== Game Logic ===== */
let gameState = {
  board: Array(9).fill(null),
  currentPlayer: 'X',
  gameActive: true,
  difficulty: 'easy', // easy, medium, hard
  stats: { wins: 0, losses: 0, attempts: 1 }
};

const winPatterns = [
  [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
  [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
  [0, 4, 8], [2, 4, 6] // diagonals
];

// Load stats from storage
async function loadStats() {
  try {
    if (window.storage) {
      const result = await window.storage.get('tictactoe-stats');
      if (result) {
        gameState.stats = JSON.parse(result.value);
        updateStatsDisplay();
      }
      
      const diffResult = await window.storage.get('tictactoe-difficulty');
      if (diffResult) {
        gameState.difficulty = diffResult.value;
        updateDifficultyDisplay();
      }
    }
  } catch (error) {
    console.log('No saved stats found');
  }
}

async function saveStats() {
  try {
    if (window.storage) {
      await window.storage.set('tictactoe-stats', JSON.stringify(gameState.stats));
      await window.storage.set('tictactoe-difficulty', gameState.difficulty);
    }
  } catch (error) {
    console.error('Failed to save stats:', error);
  }
}

function updateStatsDisplay() {
  winsEl.textContent = gameState.stats.wins;
  lossesEl.textContent = gameState.stats.losses;
  attemptsEl.textContent = gameState.stats.attempts;
  
  // Color code based on life remaining
  if (gameState.stats.attempts === 1) {
    attemptsEl.style.color = '#ef4444';
  } else {
    attemptsEl.style.color = '#9ca3af';
  }
}

function updateDifficultyDisplay() {
  difficultyBadge.textContent = gameState.difficulty.charAt(0).toUpperCase() + gameState.difficulty.slice(1);
  difficultyBadge.className = 'difficulty-badge diff-' + gameState.difficulty;
}

function checkWinner() {
  for (let pattern of winPatterns) {
    const [a, b, c] = pattern;
    if (gameState.board[a] && 
        gameState.board[a] === gameState.board[b] && 
        gameState.board[a] === gameState.board[c]) {
      return { winner: gameState.board[a], pattern };
    }
  }
  
  if (gameState.board.every(cell => cell !== null)) {
    return { winner: 'draw', pattern: null };
  }
  
  return null;
}

function highlightWinningCells(pattern) {
  if (pattern) {
    pattern.forEach(index => {
      const cell = board.children[index];
      cell.classList.add('winner');
    });
  }
}

function handleCellClick(e) {
  const cell = e.target;
  const index = parseInt(cell.dataset.index);
  
  if (!gameState.gameActive || gameState.board[index] || gameState.currentPlayer !== 'X') {
    return;
  }
  
  makeMove(index, 'X');
  
  const result = checkWinner();
  if (result) {
    endGame(result);
  } else {
    gameState.currentPlayer = 'O';
    gameStatus.textContent = "AI is thinking...";
    disable(resetBtn, true);
    
    setTimeout(() => {
      aiMove();
      const aiResult = checkWinner();
      if (aiResult) {
        endGame(aiResult);
      } else {
        gameState.currentPlayer = 'X';
        gameStatus.textContent = "Your turn! (X)";
        disable(resetBtn, false);
      }
    }, 500);
  }
}

function makeMove(index, player) {
  gameState.board[index] = player;
  const cell = board.children[index];
  cell.textContent = player;
  cell.classList.add('filled', player === 'X' ? 'player' : 'ai');
}

// AI Logic
function aiMove() {
  let move;
  
  if (gameState.difficulty === 'easy') {
    move = getRandomMove();
  } else if (gameState.difficulty === 'medium') {
    move = Math.random() < 0.5 ? getRandomMove() : getBestMove();
  } else {
    move = getBestMove();
  }
  
  makeMove(move, 'O');
}

function getRandomMove() {
  const available = gameState.board
    .map((cell, idx) => cell === null ? idx : null)
    .filter(idx => idx !== null);
  return available[Math.floor(Math.random() * available.length)];
}

function getBestMove() {
  let bestScore = -Infinity;
  let bestMove = 0;
  
  for (let i = 0; i < 9; i++) {
    if (gameState.board[i] === null) {
      gameState.board[i] = 'O';
      let score = minimax(gameState.board, 0, false);
      gameState.board[i] = null;
      
      if (score > bestScore) {
        bestScore = score;
        bestMove = i;
      }
    }
  }
  
  return bestMove;
}

function minimax(board, depth, isMaximizing) {
  const result = checkWinnerForMinimax(board);
  
  if (result !== null) {
    if (result === 'O') return 10 - depth;
    if (result === 'X') return depth - 10;
    return 0;
  }
  
  if (isMaximizing) {
    let bestScore = -Infinity;
    for (let i = 0; i < 9; i++) {
      if (board[i] === null) {
        board[i] = 'O';
        let score = minimax(board, depth + 1, false);
        board[i] = null;
        bestScore = Math.max(score, bestScore);
      }
    }
    return bestScore;
  } else {
    let bestScore = Infinity;
    for (let i = 0; i < 9; i++) {
      if (board[i] === null) {
        board[i] = 'X';
        let score = minimax(board, depth + 1, true);
        board[i] = null;
        bestScore = Math.min(score, bestScore);
      }
    }
    return bestScore;
  }
}

function checkWinnerForMinimax(board) {
  for (let pattern of winPatterns) {
    const [a, b, c] = pattern;
    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
      return board[a];
    }
  }
  
  if (board.every(cell => cell !== null)) {
    return 'draw';
  }
  
  return null;
}

function endGame(result) {
  gameState.gameActive = false;
  disable(resetBtn, false);
  
  if (result.winner === 'X') {
    gameStatus.textContent = "🎉 You Win!";
    gameState.stats.wins++;
    
    // Level up logic
    if (gameState.difficulty === 'easy') {
      gameState.difficulty = 'medium';
      showLevelUpNotice('Level Up! Now playing on MEDIUM difficulty! 💪');
    } else if (gameState.difficulty === 'medium') {
      gameState.difficulty = 'hard';
      showLevelUpNotice('Level Up! Now playing on HARD difficulty! 🔥');
    } else {
      showLevelUpNotice('Victory on HARD mode! You\'re a master! 🏆');
    }
    
    updateDifficultyDisplay();
  } else if (result.winner === 'O') {
    gameStatus.textContent = "😔 AI Wins!";
    gameState.stats.losses++;
    gameState.stats.attempts--;
    
    // Immediate game over after 1 loss
    setTimeout(() => {
      gameStatus.textContent = "💀 Game Over! You lost your life!";
      showLevelUpNotice('Game Over! Pay to play again from Easy mode...');
      disable(resetBtn, true);
      
      setTimeout(() => {
        // Reset everything
        gameState.difficulty = 'easy';
        gameState.stats.wins = 0;
        gameState.stats.losses = 0;
        gameState.stats.attempts = 1;
        updateDifficultyDisplay();
        updateStatsDisplay();
        saveStats();
        
        // Show play again button
        playAgainBtn.classList.remove('hidden');
      }, 2000);
    }, 1000);
    
    highlightWinningCells(result.pattern);
    updateStatsDisplay();
    saveStats();
    return;
  } else {
    gameStatus.textContent = "🤝 It's a Draw!";
    // Draw doesn't cost a life
  }
  
  highlightWinningCells(result.pattern);
  updateStatsDisplay();
  saveStats();
}

function showLevelUpNotice(message) {
  levelUpNotice.textContent = message;
  levelUpNotice.classList.remove('hidden');
  setTimeout(() => {
    levelUpNotice.classList.add('hidden');
  }, 4000);
}

function resetGame() {
  gameState.board = Array(9).fill(null);
  gameState.currentPlayer = 'X';
  gameState.gameActive = true;
  gameStatus.textContent = "Your turn! (X)";
  
  Array.from(board.children).forEach(cell => {
    cell.textContent = '';
    cell.classList.remove('filled', 'player', 'ai', 'winner');
  });
}

// Event Listeners
board.addEventListener('click', handleCellClick);
resetBtn.addEventListener('click', resetGame);

/* ===== Start Game (Pay-Gated) ===== */
playBtn.addEventListener('click', (e) => {
  e.preventDefault();
  payThen(async () => {
    document.getElementById('intro-overlay').classList.add('hidden');
    gameContainer.classList.remove('hidden');
    await loadStats();
    resetGame();
  }, playBtn);
});

/* ===== Play Again (Pay-Gated) ===== */
playAgainBtn.addEventListener('click', (e) => {
  e.preventDefault();
  payThen(async () => {
    playAgainBtn.classList.add('hidden');
    
    // Full reset when paying again
    gameState.difficulty = 'easy';
    gameState.stats.wins = 0;
    gameState.stats.losses = 0;
    gameState.stats.attempts = 1;
    
    updateDifficultyDisplay();
    updateStatsDisplay();
    await saveStats();
    resetGame();
    disable(resetBtn, false);
  }, playAgainBtn);
});

// Error handling
window.addEventListener('error', e => console.error('Error:', e.error || e));
window.addEventListener('unhandledrejection', e => console.error('Unhandled promise:', e.reason));
</script>
</body>
</html>

